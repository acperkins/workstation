#!/bin/bash
export ACP_BASHRC=1

if [ -d /var/acp ]
then
	export ACP=/var/acp
else
	export ACP="$HOME/data"
fi

# Set up XDG variables. See:
# https://specifications.freedesktop.org/basedir-spec/basedir-spec-latest.html
export XDG_DATA_DIRS=${XDG_DATA_DIRS:-/usr/local/share:/usr/share}
export XDG_CONFIG_DIRS=${XDG_CONFIG_DIRS:-/etc/xdg}
export XDG_DATA_HOME="${XDG_DATA_HOME:-$HOME/.local/share}"
export XDG_CACHE_HOME="${XDG_CACHE_HOME:-$HOME/.cache}"
export XDG_CONFIG_HOME="${XDG_CONFIG_HOME:-$HOME/.config}"
export XDG_STATE_HOME="${XDG_STATE_HOME:-$HOME/.local/state}"
if [ ! -d "$XDG_DATA_HOME" ]     ; then install -d -m 0700 "$XDG_DATA_HOME"   ; fi
if [ ! -d "$XDG_CACHE_HOME" ]    ; then install -d -m 0700 "$XDG_CACHE_HOME"  ; fi
if [ ! -d "$XDG_CONFIG_HOME" ]   ; then install -d -m 0700 "$XDG_CONFIG_HOME" ; fi
if [ ! -d "$XDG_STATE_HOME" ]    ; then install -d -m 0700 "$XDG_STATE_HOME"  ; fi
if [ ! -d "$HOME/.local/bin" ] ; then install -d -m 0700 "$HOME/.local/bin" ; fi

if [ -n "$BASH_VERSION" ]
then

	if [ -f /etc/bashrc ]
	then
		. /etc/bashrc
	fi

	if [ -f /usr/share/bash-completion/bash_completion ]
	then
		. /usr/share/bash-completion/bash_completion
	elif [ -f /etc/bash_completion ]
	then
		. /etc/bash_completion
	fi

fi

if [ -n "$ZSH_VERSION" ]
then
	if [ -f /etc/zshrc ]
	then
		. /etc/zshrc
	fi
fi

_acp_add_path () {
	if [ -n "$1" ] && [ -d "$1" ]
	then
		case ":$PATH:" in
			*:"$1":*)
				return
				;;
			*)
				PATH="$1:$PATH"
				export PATH
				return
				;;
		esac
	fi
}

# Last in the list means first in the path.
for dir in "$HOME/.local/bin" \
	   "$HOME/.cargo/bin" \
	   "$XDG_DATA_HOME/gem/ruby/bin" \
	   "$XDG_DATA_HOME/flatpak/exports/bin" \
	   /opt/local/bin \
	   /opt/local/sbin \
	   /var/lib/flatpak/exports/bin \
	   /usr/local/bin \
	   /usr/local/sbin \
	   /usr/bin \
	   /usr/sbin
do
	_acp_add_path "$dir"
done

umask 0022

# Locale and language.
## Clear the existing locale settings and set options I always want.
export TIME_STYLE=long-iso  # Used by GNU 'ls'.
export TZ=Europe/London  # Can override this elsewhere if needed.
if [ -f /etc/locale.conf ]
then
	. /etc/locale.conf
fi
if [ -f "$XDG_CONFIG_HOME/locale.conf" ]
then
	. "$XDG_CONFIG_HOME/locale.conf"
fi

# Other exports.
export ANSIBLE_NOCOWS=1
export EDITOR=vi
export HISTCONTROL=ignorespace:ignoredups
export PAPERSIZE=a4
export POWERSHELL_TELEMETRY_OPTOUT=1
export PYTHONWARNINGS=ignore::UserWarning

if [ "$(uname -s)" = Darwin ]
then
	export BASH_SILENCE_DEPRECATION_WARNING=1
fi

# Override this in ~/.config/bashrc or ~/.ssh/config.
export LIBVIRT_DEFAULT_URI="qemu+ssh://vmhost/system"

if test -x /usr/bin/tty
then
	GPG_TTY=$(tty)
	export GPG_TTY
fi

# Set up Vi/Vim.
if command -v vim > /dev/null
then
	export EDITOR="vim -f"
	alias vi=vim
else
	export EDITOR=vi
fi

if [ "${XDG_CURRENT_DESKTOP:-unknown}" = GNOME ]
then
	export QT_FONT_DPI=72
fi

if [ -n "$BASH_VERSION" ]
then
	set -o emacs
	set -o noclobber
	shopt -s histappend
	bind '"\e[1;5C": forward-word'
	bind '"\e[1;5D": backward-word'
	bind '"\e[A": history-search-backward'
	bind '"\e[B": history-search-forward'
	bind 'set bell-style none'
	bind 'set completion-ignore-case on'
	bind 'set enable-bracketed-paste off'
fi

if [ -n "$ZSH_VERSION" ]
then
	function history-search-end {
		#
		# This implements functions like history-beginning-search-{back,for}ward,
		# but takes the cursor to the end of the line after moving in the
		# history, like history-search-{back,for}ward.  To use them:
		#   zle -N history-beginning-search-backward-end history-search-end
		#   zle -N history-beginning-search-forward-end history-search-end
		#   bindkey '...' history-beginning-search-backward-end
		#   bindkey '...' history-beginning-search-forward-end

		integer cursor=$CURSOR mark=$MARK

		if [[ $LASTWIDGET = history-beginning-search-*-end ]]; then
			# Last widget called set $MARK.
			CURSOR=$MARK
		else
			MARK=$CURSOR
		fi

		if zle .${WIDGET%-end}; then
			# success, go to end of line
			zle .end-of-line
		else
			# failure, restore position
			CURSOR=$cursor
			MARK=$mark
			return 1
		fi
	}

	zle -N history-beginning-search-backward-end history-search-end
	zle -N history-beginning-search-forward-end history-search-end
	bindkey -e
	bindkey "^[[1;5C" forward-word
	bindkey "^[[1;5D" backward-word
	bindkey "^[[A" history-beginning-search-backward-end
	bindkey "^[[B" history-beginning-search-forward-end
	bindkey "^[OA" history-beginning-search-backward-end
	bindkey "^[OB" history-beginning-search-forward-end
fi

# Set the prompt for various shells. The prompt should look like "user@host$ "
# or similar, except for the fallback of "$ " for anything it can't detect.
if [ -n "$BASH_VERSION" ]
then
	export PS1="\[\033[01m\]\u@\h\\$\[\033[00m\] "
elif [ -n "$ZSH_VERSION" ]
then
	export PS1="%B%n@%m%#%b "
else
	export PS1="$ "
fi

if [ "$(id -u)" -ne 0 ] && [ -x /usr/bin/dnf ]
then
	alias dnf="dnf --cacheonly --nogpgcheck"
fi

alias 7zencrypt="7z a -t7z -p -mhe"
alias alu="apt list --upgradable"
alias asdo="apt source --download-only"
alias aurmake="makepkg -irs"
alias f=fossil
alias ip="ip -c"
alias isocal="cal --iso --reform=iso --monday --week"
alias la="ls -a"
alias ll="ls -l"
alias ls="command ls -F"
alias now="date +%Y%m%dT%H%M%S%z"
alias nowu="date -u +%Y%m%dT%H%M%SZ"
alias streamenc="openssl aes-256-cbc -pbkdf2 -in - -out - -e"
alias streamdec="openssl aes-256-cbc -pbkdf2 -in - -out - -d"
alias wgr=wordgrinder
alias ytmp3="youtube-dl -q -x --audio-format=mp3"
alias zlu="zypper list-updates"

# Language aliases.
alias en="LANG=en_GB.UTF-8"
alias fr="LANG=fr_FR.UTF-8"

# Alias dig to drill if dig is not installed.
if [ -x /usr/bin/drill ]
then
	alias dig=drill
fi

# Set up Go.
if [ -x "$ACP/opt/go/bin/go" ] || [ -x /usr/bin/go ] || [ -x /usr/local/bin/go ]
then
	export GOPROXY=https://proxy.golang.org
	export GOPATH="$XDG_DATA_HOME/go"
	if [ ! -d "$GOPATH" ]
	then
		mkdir -p "$GOPATH/bin"
		mkdir -p "$GOPATH/pkg"
		mkdir -p "$GOPATH/src"
	fi
	if [ -x "$ACP/opt/go/bin/go" ]
	then
		export GOROOT="$ACP/opt/go"
		_acp_add_path "$GOROOT/bin"
	fi
	_acp_add_path "$GOPATH/bin"
fi

alias prun='podman run --rm --interactive --tty --security-opt label=disable --volume "$HOME":"$HOME" --volume "$XDG_RUNTIME_DIR":"$XDG_RUNTIME_DIR" --env XDG_RUNTIME_DIR="$XDG_RUNTIME_DIR" --env XDG_SESSION_TYPE=wayland --ipc host'
alias pruncerts='prun --volume /etc/pki/ca-trust:/etc/pki/ca-trust:ro --volume /etc/ssl/certs:/etc/ssl/certs:ro'

# Desktop files (used by desktop environments within both X11 and Wayland) are
# looked for in XDG_DATA_DIRS; make sure it includes the relevant directory for
# snappy applications' desktop files.
_snap_xdg_path=/var/lib/snapd/desktop
if [ -n "${XDG_DATA_DIRS##*${_snap_xdg_path}}" ] && [ -n "${XDG_DATA_DIRS##*${_snap_xdg_path}:*}" ]
then
	export XDG_DATA_DIRS="${XDG_DATA_DIRS}:${_snap_xdg_path}"
fi
unset _snap_xdg_path

mkcd () {
	if [ $# -ne 1 ]
	then
		echo "mkcd: incorrect arguments (one directory required)." >&2
		return 1
	else
		mkdir -p "$1"
		cd "$1" || return
	fi
}

linapm () {
	cat /sys/class/power_supply/BAT0/status
	cat /sys/class/power_supply/BAT0/capacity
}

xa () {
	out=$(xrandr --listactivemonitors | awk 'NR!=1{print " "$NF" "}')
	for monitor in $out
	do
		m=$(echo "$monitor" | sed 's/ //g')
		xrandr --output "$m" --auto
	done
}

emacsro () {
	emacs "$1" -f view-mode
}

tm () {
	if tmux list-sessions > /dev/null 2>&1
	then
		tmux attach-session
	else
		tmux new-session
	fi
}

if [ -x /usr/bin/yum ] && [ ! -x /usr/bin/dnf ]
then
	alias dnf=yum
fi

if [ -S "$SSH_AUTH_SOCK" ] \
	&& [ -r "$HOME/.ssh/id_ed25519" ] \
	&& [ -r "$HOME/.ssh/id_ed25519.pub" ] \
	&& [ "$(ssh-add -l | grep -c "$(ssh-keygen -l -f "$HOME/.ssh/id_ed25519.pub")")" = 0 ]
then
	ssh-add "$HOME/.ssh/id_ed25519"
fi

if [ -r "${XDG_CONFIG_HOME:-$HOME/.config}/bashrc.local" ]
then
	. "${XDG_CONFIG_HOME:-$HOME/.config}/bashrc.local"
fi

usermotd () {
	if [ -n "$_acp_motd_shown" ]
	then
		return 1
	fi
	export _acp_motd_shown=1
	
	# OS (kernel) name and version in reverse video.
	printf "\033[7m"; uname -sr; printf "\033[0m"

	# Distro name and version on Linux and macOS.
	if [ -r /etc/os-release ]
	then
		echo "    $(. /etc/os-release; echo "$NAME" "$VERSION")"
	fi
	if [ "$(uname -s)" = "Darwin" ]
	then
		echo "    $(sw_vers -productName) $(sw_vers -productVersion)"
	fi

	# System uptime and load averages.
	uptime

	# Language for the shell.
	echo "LANG=$LANG"

	# Timezone.
	if [ -n "$TZ" ]
	then
		echo "TZ=$TZ"
	elif [ -x /usr/bin/timedatectl ] && [ "$(systemctl is-system-running)" != offline ]
	then
		timedatectl show --property=Timezone | sed 's/Timezone=/TZ=/'
	fi

	# Shell name and version.
	if [ -n "$BASH_VERSION" ]
	then
		echo "bash $BASH_VERSION"
	elif [ -n "$ZSH_VERSION" ]
	then
		echo "zsh $ZSH_VERSION"
	else
		echo "shell unknown"
	fi
}

simpletls () {
	# Create a self-signed certificate with:
	#     openssl req -new -x509 \
	#     -keyout $ACP/openssl/$(hostname)-key.pem \
	#     -out $ACP/openssl/$(hostname-cert.pem
	if [ "$1" = "-l" ]
	then
		openssl s_server -cert "$ACP/openssl/$(hostname)-cert.pem" -key "$HOME/data/openssl/$(hostname)-key.pem" -tls1_3 -port "$2"
	else
		openssl s_client -CAfile "$ACP/openssl/$1-cert.pem" -tls1_3 -connect "$1":"$2"
	fi
}

tlscheck () {
	if [ -z "$1" ]
	then
		echo "Usage: tlscheck hostname:port" >&2
	else
		openssl s_client -connect "$1" </dev/null | openssl x509 -text
	fi
}

case "$-" in
*i*)
	# Shell is interactive
	usermotd
	;;
*)
	;;
esac
